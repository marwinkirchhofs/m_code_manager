
# TOP LEVEL VIO CONTROL
# connects to a top level xilinx vio core, which acts as more of a 'prototyping' 
# hardware control interface solution that a memory mapped axi interface.
#
# how to add a new port:
# * add port to vio_ports_write/read
# * if it's a multi-bit port: set port radix in mcm_vio_init
# * add getter/setter
# * optional:
#     * set up a dict_* for the port values
#     * add the port's getter to mcm_vio_print_status
#

package require json

############################################################
# PARAMETERS
############################################################

##############################
# SYSTEM
##############################

set vio_ports_write [dict create                                                \
    sys_reset                       "probe_out0"                                \
    counter                         "counter"                                   \
]
set vio_ports_read [dict create                                                 \
    switches                        "switches"                                  \
]

# TODO: make sure that you can deterministically set this name in the top module, 
# such that it's always correct here
set name_vio_gt_interface inst_vio_ctrl
# TODO: find a generic way to determine the hw device, or to set it in the 
# project config
set name_hw_device <>

# LOOPBACK CONSTANTS
set dict_switches_status [dict create                                           \
    "1000"                          0                                           \
    "0100"                          1                                           \
    "0010"                          2                                           \
    "0001"                          3                                           \
]

##############################
# PROJECT
##############################


############################################################
# INITIALIZATION
############################################################

# get the latest *.ltx file that has been exported (via manage_hw.bash) to
# $dir_hw_export
proc _mcm_vio_get_config_probes_file {} {
    set d_project_config [::json::json2dict                                     \
                        [read [open _T_FILE_PROJECT_CONFIG_T_ r]]]
    set hw_build_name [dict get $d_project_config hw_version]
    set hw_build_path [file join $dir_hw_export $hw_build_name]

    set probes_file [lindex [                                            \
                glob [file join $dir_hw_export *.ltx]] 0 ]
    return $probes_file
}

proc mcm_vio_set_probes_file {{probes_file ""}} {
    global name_hw_device

    if {$probes_file eq ""} {
        # no probes file specified -> use the latest exported one
        set probes_file [_mcm_vio_get_config_probes_file]
    }

    set_property PROBES.FILE        $probes_file [get_hw_devices $name_hw_device]
    set_property FULL_PROBES.FILE   $probes_file [get_hw_devices $name_hw_device]
    refresh_hw_device [lindex [get_hw_devices $name_hw_device] 0]
}


############################################################
# API
############################################################

##############################
# GENERAL
##############################

# detect VIO and assign to global variable
proc mcm_vio_detect {} {
    global vio_gt_interface
    global name_hw_device
    global name_vio_gt_interface

    set vio_gt_interface [get_hw_vios                                           \
                -of_objects [get_hw_devices $name_hw_device]                    \
                -filter CELL_NAME=~$name_vio_gt_interface]
}

# write VIO output port
proc _mcm_vio_write {probe_name val} {
    global vio_gt_interface
    global vio_ports_write

    startgroup
    # assign output value to port
    set_property OUTPUT_VALUE $val [                                            \
                get_hw_probes [dict get $vio_ports_write $probe_name]           \
                -of_objects $vio_gt_interface]
    # commit port to hardware
    commit_hw_vio [                                                             \
                get_hw_probes [dict get $vio_ports_write $probe_name]           \
                -of_objects $vio_gt_interface]
    endgroup
}

# read VIO port
# Defaults to reading an input port. For getting an output port's value, specify
# output_port=1
# (depending on the type of port, you either need the INPUT_VALUE or the
# OUTPUT_VALUE property, hence the distinction in the function argument)
proc _mcm_vio_read {probe_name {output_port 0}} {
    global vio_gt_interface
    global vio_ports_read
    global vio_ports_write

    if {$output_port eq 0} {
        refresh_hw_vio $vio_gt_interface
        set read_val [get_property INPUT_VALUE [                                \
                    get_hw_probes [dict get $vio_ports_read $probe_name]        \
                    -of_objects $vio_gt_interface]]
    } else {
        set read_val [get_property OUTPUT_VALUE [                               \
                    get_hw_probes [dict get $vio_ports_write $probe_name]       \
                    -of_objects $vio_gt_interface]]
    }
    return $read_val
}

# initialize the VIO connection
# * set up probes file (the newest one that is exported, if none passed)
# * detect vio
# * set port radices
proc mcm_vio_init {{probes_file ""}} {
    global vio_gt_interface
    global vio_ports_write
    global vio_ports_read

    # INITIALIZE VIO OBJECT
    mcm_vio_set_probes_file $probes_file
    mcm_vio_detect

    # SET PORT RADICES
    # write ports
    set_property OUTPUT_VALUE_RADIX UNSIGNED [                                  \
            get_hw_probes [dict get $vio_ports_write counter]                   \
            -of_objects $vio_gt_interface]
    # read ports
    set_property INPUT_VALUE_RADIX HEX [                                        \
            get_hw_probes [dict get $vio_ports_read switches]        \
            -of_objects $vio_gt_interface]
}

##############################
# RESET
##############################

# system reset
proc mcm_vio_sys_reset {} {
    _mcm_vio_write sys_reset 1
    _mcm_vio_write sys_reset 0
}

##############################
# PORT OPERATION
##############################
# TODO: from here

# LINK STABLE
proc mcm_vio_get_link_stable {} {
    set link_stable [_mcm_vio_read link_stable]
    return $link_stable
}

# TRANSCEIVER (READY) STATUS
# transceiver
proc mcm_vio_get_transceiver_ready {} {
    set transceiver_ready [_mcm_vio_read transceiver_ready]
    return $transceiver_ready
}
# transmitter
proc mcm_vio_get_transmitter_ready {} {
    set transmitter_ready [_mcm_vio_read transmitter_ready]
    return $transmitter_ready
}
# receiver
proc mcm_vio_get_receiver_ready {} {
    set receiver_ready [_mcm_vio_read receiver_ready]
    return $receiver_ready
}

# GT LOOPBACK
proc mcm_vio_set_gt_loopback {loopback_mode} {
    global dict_gt_loopback
    _mcm_vio_write gt_loopback    [dict get $dict_gt_loopback $loopback_mode]
    mcm_vio_sys_reset
}

proc mcm_vio_get_gt_loopback {} {
    global dict_gt_loopback
    set loopback_num [_mcm_vio_read gt_loopback 1]
    set loopback [lindex [dict filter $dict_gt_loopback value $loopback_num] 0]
    return $loopback
}

# DATASTREAM LOOPBACK
proc mcm_vio_set_ds_loopback {loopback_mode} {
    global dict_ds_loopback
    _mcm_vio_write ds_loopback    [dict get $dict_ds_loopback $loopback_mode]
    mcm_vio_sys_reset
}

proc mcm_vio_get_ds_loopback {} {
    global dict_ds_loopback
    set loopback_num [_mcm_vio_read ds_loopback 1]
    set loopback [lindex [dict filter $dict_ds_loopback value $loopback_num] 0]
    return $loopback
}

# COMMA RENEWAL CYCLES
proc mcm_vio_set_comma_renewal_cycles {cycles} {
    _mcm_vio_write ds_comma_renewal_cycles $cycles
}

proc mcm_vio_get_comma_renewal_cycles {} {
    set comma_renewal_cycles [_mcm_vio_read ds_comma_renewal_cycles 1]
    return $comma_renewal_cycles
}

# WORD ALIGNMENT TIMEOUT
proc mcm_vio_set_word_alignment_timeout {timeout} {
    _mcm_vio_write ds_word_alignment_timeout $timeout
}

proc mcm_vio_get_word_alignment_timeout {} {
    set word_alignment_timeout [_mcm_vio_read ds_word_alignment_timeout 1]
    return $word_alignment_timeout
}

# RESET RETRY TIMEOUT
proc mcm_vio_set_reset_retry_timeout {timeout} {
    _mcm_vio_write gt_reset_timeout $timeout
}

proc mcm_vio_get_reset_retry_timeout {} {
    set reset_retry_timeout [_mcm_vio_read gt_reset_timeout 1]
    return $reset_retry_timeout
}

# ASYNC FIFO LOW THRESHOLD
proc mcm_vio_set_async_fifo_low_threshold {threshold} {
    _mcm_vio_write ds_async_fifo_low_threshold $threshold
    mcm_vio_sys_reset
}

proc mcm_vio_get_async_fifo_low_threshold {} {
    set async_fifo_low_threshold [_mcm_vio_read ds_async_fifo_low_threshold 1]
    return $async_fifo_low_threshold
}

# LATENCY MEASUREMENT
# status
proc mcm_vio_get_latency_meas_status {} {
    global dict_ds_meas_status
    set meas_status_num [_mcm_vio_read latency_meas_status]
    set meas_status [lindex [dict filter $dict_ds_meas_status value $meas_status_num] 0]
    return $meas_status
}

# result
proc mcm_vio_get_latency_meas_result {} {
    set meas_result [_mcm_vio_read latency_meas_result]
    return $meas_result
}

# RESET RETRY COUNT
# rx
proc mcm_vio_get_reset_retry_count_rx {} {
    set reset_retry_count_rx [_mcm_vio_read gt_reset_retry_count_rx]
    return $reset_retry_count_rx
}

# tx
proc mcm_vio_get_reset_retry_count_tx {} {
    set reset_retry_count_tx [_mcm_vio_read gt_reset_retry_count_tx]
    return $reset_retry_count_tx
}

##############################
# HIGH-LEVEL FUNCTIONALITY
##############################

proc mcm_vio_print_status {} {
    # GATHER STATUS
    set reset_retry_timeout [mcm_vio_get_reset_retry_timeout]
    set gt_loopback [mcm_vio_get_gt_loopback]
    set async_fifo_low_threshold [mcm_vio_get_async_fifo_low_threshold]
    set ds_loopback [mcm_vio_get_ds_loopback]
    set ds_comma_renewal_cycles [mcm_vio_get_comma_renewal_cycles]
    set ds_word_alignment_timeout [mcm_vio_get_word_alignment_timeout]
    set gt_reset_retry_count_rx [mcm_vio_get_reset_retry_count_rx]
    set gt_reset_retry_count_tx [mcm_vio_get_reset_retry_count_tx]
    set link_stable [mcm_vio_get_link_stable]
    set transceiver_ready [mcm_vio_get_transceiver_ready]
#     set transmitter_ready [mcm_vio_get_transmitter_ready]
#     set receiver_ready [mcm_vio_get_receiver_ready]

    # PRINT STATUS
    puts "-------------------------------------------------------------"
    puts "SYSTEM STATUS"
    # link (link stable)
    puts "LINK:           stable $link_stable"
    # GT (channels ready)
    puts "GT READY:       transceiver $transceiver_ready"
    # init (reset timeout, channel reset retry counts)
    puts "INITIALIZATION: reset timeout $reset_retry_timeout - RESET RETRY COUNT rx $gt_reset_retry_count_rx tx $gt_reset_retry_count_tx"
    # loopback (gt, datastream)
    puts "LOOPBACK:       GT $gt_loopback - datastream $ds_loopback"
    # sequencer (async fifo thresh, comma renewal, word alignment timeout)
    puts "SEQUENCER:      fifo low $async_fifo_low_threshold - comma renewal $ds_comma_renewal_cycles - word alignment timeout $ds_word_alignment_timeout"
    puts "-------------------------------------------------------------"
}

# perform a latency measurement and print the results
proc mcm_vio_measure_latency {} {
    # check link status
    # TODO

    # trigger measurement
    _mcm_vio_write latency_meas_trigger 1
    _mcm_vio_write latency_meas_trigger 0

    # wait for result (10ms)
    after 10

    # check measurement result
    set meas_status [mcm_vio_get_latency_meas_status]
    set meas_result [mcm_vio_get_latency_meas_result]

    puts "latency measurement status: $meas_status"
    puts "latency measurement result: $meas_result"
}

##############################
# DEFAULTS
##############################

# initialize system to operation mode defaults
proc mcm_vio_set_defaults {{mode ""}} {
    _mcm_vio_write latency_meas_trigger 0

    # reset timeout:                60000
    # word alignment timeout:       1e3
    # comma renewal cycles:         1e5
    mcm_vio_set_reset_retry_timeout       60000
    mcm_vio_set_word_alignment_timeout    1000
    mcm_vio_set_comma_renewal_cycles      100000

    switch $mode {
        "no_loopback" {
            # GT loopback:                  off
            # data sequencer loopback:      off
            # async FIFO low threshold:     2
            mcm_vio_set_gt_loopback                  disable
            mcm_vio_set_ds_loopback                  disable
            mcm_vio_set_async_fifo_low_threshold  2
        }
        "near_end_pma_loopback" {
            # GT loopback:                  near-end PMA loopback
            # data sequencer loopback:      off
            # async FIFO low threshold:     5
            mcm_vio_set_gt_loopback                  loopback_near_pma
            mcm_vio_set_ds_loopback                  disable
            mcm_vio_set_async_fifo_low_threshold  5
        }
        "far_end_pma_loopback" {
            # GT loopback:                  far-end PMA loopback
            # data sequencer loopback:      off
            # async FIFO low threshold:     5
            mcm_vio_set_gt_loopback                  loopback_far_pma
            mcm_vio_set_ds_loopback                  disable
            mcm_vio_set_async_fifo_low_threshold  5
        }
        "ds_rx_loopback" {
            # GT loopback:                  off
            # data sequencer loopback:      on
            # async FIFO low threshold:     2
            mcm_vio_set_gt_loopback                  disable
            mcm_vio_set_ds_loopback                  loopback_rx
            mcm_vio_set_async_fifo_low_threshold  2
        }
        default {
            puts "Please specify one of the supported modes:"
            puts "no_loopback, near_end_pma_loopback, far_end_pma_loopback, ds_rx_loopback"
        }
    }
    mcm_vio_sys_reset
}

