
# TOP LEVEL VIO CONTROL
# connects to a top level xilinx vio core, which acts as more of a 'prototyping' 
# hardware control interface solution that a memory mapped axi interface.
#
# how to add a new port:
# * add port to vio_ports_write/read
# * if it's a multi-bit port: set port radix in mcm_vio_init
# * add getter/setter
# * optional:
#     * set up a dict_* for the port values
#     * add the port's getter to mcm_vio_print_status
#
# TODO: try to automatically obtain both the vio connections and the internal 
# names on the IP ports. The vio port names you should get from some xml in the 
# IP directory, the connections would either also come from there, or you get 
# them from parsing the top level RTL file. If you got that, you can also to 
# some extent automatically generate getter and setter methods.
#

package require json

############################################################
# PARAMETERS
############################################################

##############################
# SYSTEM
##############################

set vio_ports_write [dict create                                                \
    sys_reset                       "probe_out0"                                \
    counter                         "counter"                                   \
]
set vio_ports_read [dict create                                                 \
    switches                        "switches"                                  \
]

# TODO: make sure that you can deterministically set this name in the top module, 
# such that it's always correct here
set name_vio_gt_interface inst_vio_ctrl
# TODO: find a generic way to determine the hw device, or to set it in the 
# project config
set name_hw_device <>

# LOOPBACK CONSTANTS
set dict_switches_status [dict create                                           \
    "1000"                          0                                           \
    "0100"                          1                                           \
    "0010"                          2                                           \
    "0001"                          3                                           \
]

##############################
# PROJECT
##############################


############################################################
# INITIALIZATION
############################################################

# get the latest *.ltx file that has been exported (via manage_hw.bash) to
# $dir_hw_export
proc _mcm_vio_get_config_probes_file {} {
    set d_project_config [::json::json2dict                                     \
                        [read [open _T_FILE_PROJECT_CONFIG_T_ r]]]
    set hw_build_name [dict get $d_project_config hw_version]
    set hw_build_path [file join $dir_hw_export $hw_build_name]

    set probes_file [lindex [                                            \
                glob [file join $dir_hw_export *.ltx]] 0 ]
    return $probes_file
}

proc mcm_vio_set_probes_file {{probes_file ""}} {
    global name_hw_device

    if {$probes_file eq ""} {
        # no probes file specified -> use the latest exported one
        set probes_file [_mcm_vio_get_config_probes_file]
    }

    set_property PROBES.FILE        $probes_file [get_hw_devices $name_hw_device]
    set_property FULL_PROBES.FILE   $probes_file [get_hw_devices $name_hw_device]
    refresh_hw_device [lindex [get_hw_devices $name_hw_device] 0]
}


############################################################
# API
############################################################

##############################
# GENERAL
##############################

# detect VIO and assign to global variable
proc mcm_vio_detect {} {
    global vio_gt_interface
    global name_hw_device
    global name_vio_gt_interface

    set vio_gt_interface [get_hw_vios                                           \
                -of_objects [get_hw_devices $name_hw_device]                    \
                -filter CELL_NAME=~$name_vio_gt_interface]
}

# write VIO output port
proc _mcm_vio_write {probe_name val} {
    global vio_gt_interface
    global vio_ports_write

    startgroup
    # assign output value to port
    set_property OUTPUT_VALUE $val [                                            \
                get_hw_probes [dict get $vio_ports_write $probe_name]           \
                -of_objects $vio_gt_interface]
    # commit port to hardware
    commit_hw_vio [                                                             \
                get_hw_probes [dict get $vio_ports_write $probe_name]           \
                -of_objects $vio_gt_interface]
    endgroup
}

# read VIO port
# Defaults to reading an input port. For getting an output port's value, specify
# output_port=1
# (depending on the type of port, you either need the INPUT_VALUE or the
# OUTPUT_VALUE property, hence the distinction in the function argument)
proc _mcm_vio_read {probe_name {output_port 0}} {
    global vio_gt_interface
    global vio_ports_read
    global vio_ports_write

    # TODO: couldn't you just get rid of the read/write distinction, if you just 
    # always update the vio, and then look up both dictionaries? Then you just 
    # have to impose no double signal names, should be common sense at least.
    if {$output_port eq 0} {
        refresh_hw_vio $vio_gt_interface
        set read_val [get_property INPUT_VALUE [                                \
                    get_hw_probes [dict get $vio_ports_read $probe_name]        \
                    -of_objects $vio_gt_interface]]
    } else {
        set read_val [get_property OUTPUT_VALUE [                               \
                    get_hw_probes [dict get $vio_ports_write $probe_name]       \
                    -of_objects $vio_gt_interface]]
    }
    return $read_val
}

# initialize the VIO connection
# * set up probes file (the newest one that is exported, if none passed)
# * detect vio
# * set port radices
proc mcm_vio_init {{probes_file ""}} {
    global vio_gt_interface
    global vio_ports_write
    global vio_ports_read

    # INITIALIZE VIO OBJECT
    mcm_vio_set_probes_file $probes_file
    mcm_vio_detect

    # SET PORT RADICES
    # write ports
    set_property OUTPUT_VALUE_RADIX UNSIGNED [                                  \
            get_hw_probes [dict get $vio_ports_write counter]                   \
            -of_objects $vio_gt_interface]
    # read ports
    set_property INPUT_VALUE_RADIX HEX [                                        \
            get_hw_probes [dict get $vio_ports_read switches]                   \
            -of_objects $vio_gt_interface]
}

##############################
# RESET
##############################

# system reset
proc mcm_vio_sys_reset {} {
    _mcm_vio_write sys_reset 1
    _mcm_vio_write sys_reset 0
}

##############################
# PORT OPERATION
##############################
# TODO: from here

# example: read from a read port
proc mcm_vio_get_switches {} {
    set switches [_mcm_vio_read switches]
    return $switches
}

# example: write to a write port
proc mcm_vio_set_counter {counter} {
    _mcm_vio_write counter $timeout
}

# example: read from a write port
proc mcm_vio_get_counter {} {
    set counter [_mcm_vio_read counter 1]
    return $counter
}

##############################
# HIGH-LEVEL FUNCTIONALITY
##############################

proc mcm_vio_print_status {} {
    # GATHER STATUS
    set switches [mcm_vio_get_switches]
    set counter [mcm_vio_get_counter]

    # PRINT STATUS
    puts "-------------------------------------------------------------"
    puts "SYSTEM STATUS"
    # counter
    puts "COUNTER:        $counter"
    # switches
    puts "SWITCHES:       switches"
    puts "-------------------------------------------------------------"
}

# example: perform an operation
proc mcm_vio_perform_operation {} {

    # trigger measurement
    mcm_vio_set_counter 1

    # wait for hardware processing (10ms)
    after 10

    # check status
    set status [mcm_vio_get_switches]

    puts "switch position: $status"
}

##############################
# DEFAULTS
##############################

# initialize system to operation mode defaults
proc mcm_vio_set_defaults {{mode ""}} {

    # -------------------- #
    # (non-mode dependent default values here)
    # -------------------- #

    switch $mode {
        "standard" {
            # -------------------- #
            # (mode dependent default values here)
            # -------------------- #
        }
        default {
            puts "Please specify one of the supported modes:"
            puts "standard"
        }
    }
    mcm_vio_sys_reset
}

# if the script is called, instead of sourced
if {[info exists ::argv0] && $::argv0 eq [info script]} {
    # initiate hw manager
    open_hw
    connect_hw_server
    open_hw_target

    # detect vio, set up probes file and initialise vio
    mcm_vio_init
}
