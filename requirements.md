# COMMANDS

* mcm
    * *
        * git           - if there is no git repo present, create it; generate 
          all missing gitignores (reason to also let `git` be prepended by 
          language selection: consisency of usage and that way the tools knows 
          the correct subdirectories/gitignores and doesn't have to guess)
    * py/python
        * init      - top-level script including main-structure, make, 
          vimspector
        * package   - package including init file
        * vimspector - create vimspector config file
        * make      - run
    * c/cpp
    * sv/systemverilog, vhdl
        * init      - directory structure, all other sv/systemverilog targets 
          (TODO: how to set the part/board?)
        * project   - vivado project build tcl script;
                        * read source directory structure
                        * read every project component script if it exists (ip 
                          generation script for example)
                        * process options
                            * part - if none is given, still add the line and 
                              make it an empty-string variable
                            * top module (also create the top module if it 
                              doesn't exist?)
                        * if project exists, the script should still update it 
                          with the respective things like part
        * ip        - dict-based ip generation tcl script
        * testbench - create a testbench for a certain module (=target)
        * hw_export - export hardware script
        * vio_if    - if they don't exist, skeleton for VIO interfacing tcl 
          script and make targets
        * make      - makefile with all applicable targets (don't care if the 
          respective scripts weren't generated): create project including ps bd, 
          build, vivado sim, reports, program FPGA, initiate PS (if present), sw 
          (calls sw target in src directory which is generated by sdk->..., so 
          that you can still differentiate between standalone app and linux)
        * sdk
            * standalone - generate directory structure, c code skeletons, tcl 
              scripting, subdirectory makefile
            * linux - TODO/later
        * axi_if    - create an AXI interface RTL file (or update it) based on 
          an interface description file (probably yaml, specifying axi-type, 
          registers, addresses, register types (trigger or reg))
        * inst      - echo the code to instantiate a module that is present in 
          the project
                    design idea is to require extra text editor-specific 
                    scripting for allowing updating an existing module 
                    instantiation, something like: mcm generates the plain 
                    instantiation into a temporary file; vim checks if the 
                    cursor is within an existing instantiation for the same 
                    module, and if it is, line by line interprets the temporary 
                    file to insert (or remove/comment out) code only where 
                    necessary; then vim deletes the temporary file
    * sv/systemverilog
        * module    - create an sv module
        * verilator - verilator and gtkwave scripting, make target, top-level 
          testbench skeleton?

# REQUIREMENTS

# Functionality

## General Features

* parameterizable code-style engine (indentation etc.)
    * language support
        * python
        * c/c++
        * vhdl
        * (system)verilog
        * tcl
* every language-specific functionality accessible for acting on an existing 
  codebase
    * if a generated file exists, ask before overwriting it
        * in that case, option to keep original files for controlling correct 
          functionality/reverting capability
    * for makefiles, add new targets to existing makefiles
* convenient extendability interface -> ensure that others can contribute 
  without having to know the internals of the codebase

## Language-independent features
* git repo
    * including gitiginores in subdirectories
* necessary make targets
    * compilation
    * project inspection (if applicable)
* source file directory structure

## Language-specific Functionality

* Python
    * vimspector
    * python package with python init file
    * top-level script with main
* C/C++
    * vimspector
    * CMake base file
    * ```main.c/cpp```
* HDL
    * support for VHDL and SystemVerilog
    * simulation
        * verilator/gtkwave simulation
            * systemc axi interface simulation
        * third-party simulator library compilation and script generation
        * selectable top module
    * Vivado workflow support
        * project-mode only
            * set up runs with different presets in a convenient way (yaml?)
            * error/warning count output for synthesis/implementation (colored 
              in the best case)
        * view reports
        * export generated hardware
        * top-level RTL that instantiates a block design
        * dictionary based Xilinx IP generation
            * allow multiple IP description files, such that for example debug 
              cores and essential project IPs can go into different files
        * SDK
            * standalone application generation (including bsp etc)
        * board interfacing
            * program the FPGA
            * initiate PS (if present)
        * VIO top-level interface tcl script
        * design checkpoint loading (for example to inspect netlist, placement, 
          clock interaction...)
    * AXI (lite) interface generator
    * module instantiation engine
